<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
		</style>
	</head>
	<body onload="Calculate()">
	<a href="../Readme.html#MemoryCalculator">Back</a><br><br>
	
	
	Note: This javascript calculator uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><kbd>BigInt</kbd></a> as its number format. Make sure your
	browser supports this format. Currently (the time of writing 2019-12-29), edge, IE (why use this browser?), safari (and IOS) don't support this format. The reason is because to prevent a potential
	rounding issues with the precision, <kbd>Math.floor(x/y)</kbd> could have the quotient be rounded up before the floor function kicks in). An example is this: <kbd>Math.floor(100000000000000.9999)</kbd>,
	its between <kbd>100000000000000</kbd> and <kbd>100000000000001</kbd>, however, it is rounded towards <kbd>100000000000001</kbd> and not <kbd>100000000000000</kbd>, which is wrong.<br><br>
	
	<kbd>!Freeram_MemoryFlag = </kbd>$<input type="text" onchange="Calculate()" value="7FAD49" id="Freeram_MemoryFlag" list="MemoryFlagTables"><button onclick="BigintIncreaseDecreaseHexInput(1n, 'Freeram_MemoryFlag', 0n, BigInt('0xFFFFFF')) ">+</button><button onclick="BigintIncreaseDecreaseHexInput(-1n, 'Freeram_MemoryFlag', 0n, BigInt('0xFFFFFF')) ">-</button>
	<datalist id="MemoryFlagTables">
	<option value="7FAD49">Default RAM address</option>
	<option value="4001B9">Default RAM address (SA-1)</option>
	</datalist><br>
	Number of group-128s = <input type="number" onchange="Calculate()" value="2" min="1" max="16" id="NumberOfGroup128"><br><br>
	
	
	<button onclick="reset()">Reset</button>
	<span id="Output"></span>
<script>
	function reset() {
		document.getElementById("Freeram_MemoryFlag").value = "7FAD49"
		document.getElementById("NumberOfGroup128").value = "2"
		Calculate()
	}
	function Calculate() {
		var MemoryFlag = BigintClamp(CorrectHexBigIntValue(document.getElementById("Freeram_MemoryFlag").value), 0n, BigInt("0xFFFFFF"))
		document.getElementById("Freeram_MemoryFlag").value = MemoryFlag.toString(16).toUpperCase()
		var NumberOfGroup128 = BigintClamp(BigInt(document.getElementById("NumberOfGroup128").value), 1n, 16n)
		document.getElementById("NumberOfGroup128").value = NumberOfGroup128.toString(10)
		
		var NumberOfBytes = NumberOfGroup128*16n
		var TotalNumberOfBits = NumberOfBytes*8n
		
		var Output = ""
		document.getElementById("Output").innerHTML = ""
		
		
		
		Output += "<table>"
		Output += "<tr><th colspan='2'>Total size and entire range</th></tr>"
		Output += "<tr>"
		Output += "<td><kbd>!Freeram_MemoryFlag</kbd> range:</td>"
		Output += "<td><kbd>$" + MemoryFlag.toString(16).toUpperCase() + "</kbd> to <kbd>$" + (MemoryFlag+(NumberOfBytes-1n)).toString(16).toUpperCase() + "</kbd> (<kbd>!Freeram_MemoryFlag</kbd> to <kbd>!Freeram_MemoryFlag+$" + (NumberOfBytes-1n).toString(16).toUpperCase() + "</kbd>), <kbd>" + NumberOfBytes.toString(10) + "</kbd> bytes</td>"
		Output += "</tr>"
		Output += "<tr>"
		Output += "<td>Bit numbering range:</td>"
		Output += "<td><kbd>0</kbd> to <kbd>" + (TotalNumberOfBits-1n).toString(10) + "</kbd> (<kbd>$0</kbd> to <kbd>$" + (TotalNumberOfBits-1n).toString(16).toUpperCase() + "</kbd>, <kbd>" + TotalNumberOfBits.toString(10) + "</kbd> bits)</td>"
		Output += "</tr>"
		if (NumberOfGroup128 >= 2n) {
			var GroupCount = 0n
			Output += "<tr><th colspan='2'>Subranges of each group</th></tr>"
			for (GroupCount = 0n; GroupCount < NumberOfGroup128; GroupCount++) {
				Output += "<tr>"
				Output += "<td>Group <kbd>$" + GroupCount.toString(16).toUpperCase() + "</kbd> (bit numbers <kbd>" + (GroupCount*128n).toString(10) + "</kbd> to <kbd>" + ((GroupCount*128n)+127n).toString(10) + "</kbd>)</td>"
				Output += "<td><kbd>$" + (MemoryFlag+(GroupCount*16n)).toString(16).toUpperCase() + "</kbd> to <kbd>$" + (MemoryFlag+((GroupCount*16n)+15n)).toString(16).toUpperCase() + "</kbd> (<kbd>!Freeram_MemoryFlag+$" + (GroupCount*16n).toString(16).toUpperCase() + "</kbd> to <kbd>!Freeram_MemoryFlag+$" + ((GroupCount*16n)+15n).toString(16).toUpperCase()  + "</kbd>)</td>"
				Output += "</tr>"
			}
		}
		
		Output += "</table><br>"
		
		var BitIndexCount = 0n
		var WhatBitInByte = [
		"<kbd>%-------X</kbd> (bit <kbd>0</kbd>)",
		"<kbd>%------X-</kbd> (bit <kbd>1</kbd>)",
		"<kbd>%-----X--</kbd> (bit <kbd>2</kbd>)",
		"<kbd>%----X---</kbd> (bit <kbd>3</kbd>)",
		"<kbd>%---X----</kbd> (bit <kbd>4</kbd>)",
		"<kbd>%--X-----</kbd> (bit <kbd>5</kbd>)",
		"<kbd>%-X------</kbd> (bit <kbd>6</kbd>)",
		"<kbd>%X-------</kbd> (bit <kbd>7</kbd>)",
		]
		
		Output += "<table>"
		Output += "<tr>"
		Output += "<th>Address of <kbd>!Freeram_MemoryFlag</kbd></th>"
		Output += "<th>LM's <kbd>$7FC060</kbd> address</th>"
		Output += "<th><kbd>!Freeram_MemoryFlag</kbd> flag number</th>"
		Output += "<th><kbd>$7FC060</kbd> flag number</th>"
		Output += "<th>Bit in byte</th>"
		Output += "</tr>"
		
		for (BitIndexCount = 0n; BitIndexCount < TotalNumberOfBits; BitIndexCount++) {
			if ((BitIndexCount % 128n) == 0n) {
				Output += "<tr><th colspan='5'>Group <kbd>$" + (BitIndexCount/128n).toString(16).toUpperCase() + "</kbd></th></tr>"
			}
			Output += "<tr>"
			if ((BitIndexCount % 8n) == 0n) {
				Output += "<td rowspan='8'><kbd>$" + (MemoryFlag+(BitIndexCount/8n)).toString(16).toUpperCase() + "</kbd> (<kbd>!Freeram_MemoryFlag+$" + (BitIndexCount/8n).toString(16).toUpperCase() + "</kbd>)</td>"
			}
			if ((BitIndexCount % 8n) == 0n) {
				//$7FC060 = 8372320
				Output += "<td rowspan='8'><kbd>$" + (8372320n + (BitIndexCount/8n) % 16n).toString(16).toUpperCase()  + "</kbd></td>"
			}
			Output += "<td><kbd>" + BitIndexCount.toString(10) + "</kbd> (<kbd>$" + BitIndexCount.toString(16).toUpperCase() + "</kbd>)</td>"
			Output += "<td><kbd>" + (BitIndexCount % 128n).toString(10) + "</kbd> (<kbd>$" + (BitIndexCount % 128n).toString(16).toUpperCase() + "</kbd>)</td>"
			Output += "<td>" + WhatBitInByte[BitIndexCount % 8n] + "</td>"
			Output += "</tr>"
		}
		Output += "</table><br><br>"
		
		//Generate placeholder tables
		Output += "<h2>Placeholder for ASM tables</h2>"
		Output += "<h3>SRAM/BWRAM plus</h3>"
		Output += "<table><tr><td><pre>"
		Output += "	dl $" + MemoryFlag.toString(16).toUpperCase() + " : dw " + NumberOfBytes.toString(10) + "<br>"
		Output += "	;[...]<br>"
		var PlaceHolderLoopCount = 0
		for (PlaceHolderLoopCount = 0; PlaceHolderLoopCount < NumberOfBytes; PlaceHolderLoopCount++) {
			Output += "	db %11111111		;&gt;!Freeram_MemoryFlag+$" + PlaceHolderLoopCount.toString(16).toUpperCase() + "<br>"
		}
		Output += "</pre></td></tr></table>"
		
		Output += "<h3>SearchBlockFlagIndex.asm (custom blocks routine)</h3>"

		Output += "<table><tr><td><pre>"
		Output += "?GetFlagNumberLevelIndexStart:<br>"
		for (PlaceHolderLoopCount = 0; PlaceHolderLoopCount < TotalNumberOfBits; PlaceHolderLoopCount++) {
			Output += "	dw $FFFF		;&gt;Flag " + PlaceHolderLoopCount.toString(10) + "<br>"
		}
		Output += "	;[...]<br>"
		Output += "?GetFlagNumberLayerProcessingStart:<br>"
		for (PlaceHolderLoopCount = 0; PlaceHolderLoopCount < TotalNumberOfBits; PlaceHolderLoopCount++) {
			Output += "	db $00		;&gt;Flag " + PlaceHolderLoopCount.toString(10) + "<br>"
		}
		Output += "	;[...]<br>"
		Output += "?GetFlagNumberC800IndexStart:<br>"
		for (PlaceHolderLoopCount = 0; PlaceHolderLoopCount < TotalNumberOfBits; PlaceHolderLoopCount++) {
			Output += "	dw GetC800IndexHorizLvl($01B0, $0000, $0000)		;&gt;Flag " + PlaceHolderLoopCount.toString(10) + "<br>"
		}
		Output += "</pre></td></tr></table><br>"
		
		Output += "<h3>MBCM16WriteTo7FC060.asm (uberasm tool)</h3>"
		Output += "Note: if you have any levels not using the MBCM16, feel free to delete from the bottom up."
		Output += "<table><tr><td><pre>"
		Output += ".LevelList<br>"
		for (PlaceHolderLoopCount = 0; PlaceHolderLoopCount < 512; PlaceHolderLoopCount++) {
			//Assuming if all levels would ever use the group-128
			Output += "	dw $FFFF		;&gt;Order number " + PlaceHolderLoopCount.toString(10) + "<br>"
		}
		Output += ".OneHundredTwentyEightFlagGroupList<br>"
		for (PlaceHolderLoopCount = 0; PlaceHolderLoopCount < 512; PlaceHolderLoopCount++) {
			Output += "	db $00			;&gt;Order number " + PlaceHolderLoopCount.toString(10) + "<br>"
		}


		//And edit the HTML via JS code
		document.getElementById("Output").innerHTML = Output
	}
	function BigintClamp(num, min, max) {
		//Restrict a number within a specified range, bigInt edition.
		return num <= min ? min : num >= max ? max : num;
	}
	function BigintIncreaseDecreaseHexInput(ChangeBy, WhatInput, Min, Max) {
		//To be used along with a hex input the user enters.
		//This function is for the increment/decrement buttons since
		//only the "number" input (only allows characters 0-9) allows
		//the increment/decrement action (up/down button when selected,
		//and pressing up and down)
		document.getElementById(WhatInput).value = BigintClamp((CorrectHexBigIntValue(document.getElementById(WhatInput).value) + ChangeBy), Min, Max).toString(16).toUpperCase()
		Calculate()
	}
	function CorrectHexBigIntValue(String) {
		//This converts the user's input hex string (negative numbers not allowed)
		//to BigInt.
		if ((/^([0-9]|[A-F]|[a-f])+$/).test(String) == false) {
			String = 0n
		}
		return CanConvertHexStringToBigInt = BigInt("0x" + String)
	}
</script>