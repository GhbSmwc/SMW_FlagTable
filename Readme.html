<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
		</style>
	</head>
<body>
<center><h1>Memory-based Conditional map 16 blocks</h1></center>
<h2>Introduction</h2>

<p>This ASM resource allows you to have more than 128 bit flags in your entire game. This is useful for exploration-based hacks should you have blocks that
shouldn't respawn when the player refreshes the level. An example is locked doors and keys, especially involving backtracking. Another use, which is minor, is
SA-1 hacks, since blocks are processed during SA-1, they do not have access to WRAM (RAM address in banks <kbd>$7E</kbd> and <kbd>$7F</kbd>), thus the blocks
themselves cannot use <kbd>$7FC060</kbd> directly. Instead have blocks to use banks <kbd>$40</kbd> or <kbd>$41</kbd>, then uberasm tool to transfer that to <kbd>$7FC060</kbd>
making it possible for custom blocks to use CM16 blocks on a SA-1 hack.</p>

<p>Note that this isn't really a <b>true</b> conditional map 16 expansion, this is because this ASM resource relies on Lunar Magic's conditional map16 blocks
(<kbd>$7FC060</kbd> to <kbd>$7FC06F</kbd>), therefore, you can use up to 128 flags <u>per level</u>. This ASM resource just creates a new RAM area defined as
<kbd>!Freeram_MemoryFlag</kbd> and &ldquo;divide&rdquo; them into groups of 16 bytes (I call them &ldquo;Group-128&rdquo;, 16 bytes = 128 bits). Depending on what level you are in, during level load, all 16 bytes
within a specified group (set by the table in <kbd>UberasmTool/Library/MBCM16WriteGroup128To7FC060.asm</kbd> under the sublabel <kbd>.OneHundredTwentyEightFlagGroupList</kbd>)
will copy itself into <kbd>$7FC060</kbd>-<kbd>$7FC06F</kbd> to make the blocks spawn, not spawn anymore, or remain changed when the player leaves and return.</p>

<p>Keep in mind, you are not forced to use a different group-128 for every level, you can reuse the same group-128 in multiple levels should the level uses less than 128 flags.
Just be careful not to have a separate block in another level be inadvertently set the same LM flag number (which also means the same flag number for <kbd>!Freeram_MemoryFlag</kbd>)
as the other level of the same group (example: Two levels, 105 and 106, both use group 0, one block is a key set to 0, the other level also have a key set to 0, picking up one key
will affect the spawning of the other key, which you should avoid).</p>

<p><kbd>!Freeram_MemoryFlag</kbd> is <kbd>NumberOfGroups*$10</kbd> bytes long. <kbd>NumberOfGroups</kbd> is how many group-128s you wanted,
ranging from 1-16. Therefore, the absolute limit on how many bit flags you can have in the entire game is 2048. I don't think any hack would ever need this many flags,
even if all the playable levels on an average hack uses this mechanic.</p>

<p>This RAM acts as a universal global memory, and shouldn't be reset on level load and overworld (it must be &ldquo;untouched&rdquo; RAM initialized by the SRAM/BWRAM patch when the user starts the game).</p>

<p>The blocks included in this ASM resources is a key (collectible and not carried like a key sprite) and locked door. How this works using this resource is that unlike
the hack <i>Mushroom Kingdom - Under Crimson Skies</i>, this ASM pack do not use duplicate map16 blocks each having their own flag to write, instead when the player
triggers the block, the block checks what level,  if its on layer 1 or 2, and its location within the level. If all 3 of these attributes are found on a specific index number,
will use that index number to determine what flag number to set/reset a bit in <kbd>!Freeram_MemoryFlag</kbd>, otherwise it will do nothing as a failsafe.</p>

<h2>What you need</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=21211">Lunar Magic</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=19047">Gopher Popcorn Stew</a> (block inserter)</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=19982">UberASM Tool</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=18531">SRAM/BWRAM plus patch</a></li>
</ul>

<h2>Useful stuff provided here</h2>
<ul>
<li>I made a <span id="MemoryCalculator"><a href="Readme_files/JS_MemoryCalculator.html">Javascript tool</a></span> that displays the memory statistics along with what flag gets written to what flag in <kbd>$7FC060</kbd>,
good for debugging among other things.</li>
</ul>

<h2>Insertion</h2>
<ol>
	<li>
		<p>Freerams and tables:</p>
		<ol>
			<li>
				<p>Because the blocks check their locations and level numbers, you must open these files:</p>
				<ul>
					<li><p><kbd>UberasmTool/Library/MBCM16WriteGroup128To7FC060.asm</kbd></p></li>
					<li><p><kbd>Blocks/routines/SearchBlockFlagIndex.asm</kbd></p></li>
					<li><p><kbd>Blocks/routines/GetWhatKeyCounter</kbd></p></li>
				</ul>
				<p>These contains a list of level numbers, block location within level and group numbers (times <kbd>$10</kbd>), and what key counter for the level to use. You may have to come back,
				edit the tables, and re-insert the blocks and uberasm tool as you edit levels. Comments should fully explained how each table correspond.
				Even better is that the JS tool (linked previously) also print out the tables (with comments pointing of each item and their flag numbers/Level ID) for you
				to copy.</p>
				
				<li><p>Open <kbd>FlagMemoryDefines/Defines.asm</kbd> and edit <kbd>!Freeram_MemoryFlag</kbd> if you find RAM conflicts with another ASM resource. I highly
				recommend make note as (including before and after) you insert any patches (including third party) so it is easier to keep track of.</p></li>
			</li>
		</ol>
	</li>
	<li>
		Using SRAM/BWRAM plus patch.
		<ol>
			<li>
				<p>Open either SRAM or BWRAM plus depending on if your hack is SA-1 or not. Now again, using the JS tool, copy the given ASM tables from an obviously named
				section and paste them accordingly. Remember that the order in table and defaults must match (the first <kbd>dl $xxxxxx : dw $yyyy</kbd> goes to the first group of bytes
				in &ldquo;<kbd>defaults</kbd>&rdquo;, second on second, and so on). Remember that this is the default value they would be when you start a new game.</p>
				
				<p>This here is the default values that are going to be copied to <kbd>$7FC060-$7FC06F</kbd> upon entering a stage using this ASM resource.</p>
				
				<p>Keep in mind about LM's CM16:</p>
				<ul>
					<li>
						<p>With &ldquo;Always show objects&rdquo; unchecked, if the flag is 0, it uses tile <kbd>$0025</kbd>, otherwise use the tile you've just placed down. If you want
						something to not exist but later in the game to appear, then you should default the flag to 0 and SET the bit on an event the player does something to make it appear.
						To make it disappear and stays gone forever, you should default the flag to 1 and CLEAR the flag on an event the player does something to make it gone forever (such as
						when the player picks up the key).</p>
					</li>
					<li>
						<p>With &ldquo;Always show objects&rdquo; checked, if the flag is 0, it uses the tile you've placed down, otherwise it will use <kbd>Tile_Youve_Placed_Down+$0100</kbd> (example:
						if you use tile <kbd>$0425</kbd>, it will use that tile when the flag is 0, otherwise it will use <kbd>$0<u>5</u>25</kbd>, which is the next map16 page keeping its low byte).</p>
						
						<p>Seems only useful if you don't want to use tile <kbd>$0025</kbd>. To keep things organized when using both settings (&ldquo;Always show objects&rdquo; checked
						for some blocks and unchecked for others), I would recommend having all the default values in this table be set (<kbd>$11111111</kbd>) and always clear them when the
						player triggers something, and have the intended &ldquo;inital&rdquo; block state on the second of the two map16 pages (<kbd>$0525</kbd> (inital) &rightarrow; <kbd>$0425</kbd> (block you place)).</p>
					</li>
				</ul>
				<p>Thus, you are not restricted to using all eight ones or all eight zeroes in the bytes.</p>
				
			</li>
		</ol>
	</li>
	<li>
		<p>Uberasm tool insertion</p>
		<ol>
			<li>
				<p>In any level that are using the flags, create/edit a .asm file (like <kbd>Level105.asm</kbd>), in that file, paste this code as <kbd>load:</kbd>:
<table><tr><td><pre>load:
	JSL MBCM16WriteGroup128To7FC060_LoadFlagTableToCM16
	;[...]
	RTL
</pre></td></tr></table>
				What will happen is when the level loads, <kbd>$7FC060</kbd> is now written from <kbd>!Freeram_MemoryFlag+(&lt;Group_Number&gt;*$10)</kbd> to
				<kbd>!Freeram_MemoryFlag+((&lt;Group_Number&gt;*$10)+$0F)</kbd>. Group number is found in <kbd>.OneHundredTwentyEightFlagGroupList</kbd>
				in <kbd>UberasmTool/Library/MBCM16WriteGroup128To7FC060.asm</kbd></p>
			</li>
		</ol>
	</li>
	<li>Block insertion</li>
	<ol>
		<li>
			<p>Copy the list of blocks in <kbd>Blocks/list.txt</kbd> and paste it in GPS's list file. You may need to edit their map16 number (or ID number).</p>
		</li>
		<li>
			<p>Copy and paste the block and routine ASM files, their folders should have obvious names to know where to put.</p>
		</li>
	</ol>
	<li>LM and the CM16 flag number</li>
	<ol>
		<li>
			Graphics
		</li>
		<li>
			Placing blocks in level
		</li>
	</ol>
</ol>
<h2>Troubleshooting</h2>
<ul>
	<li>
		If you're unsure if you had set up the flag and level tables correctly I have some protips:
		<ul>
			<li>
				<p>Use the block <kbd>Template_PermaDisappear.asm</kbd>, place it in the level, and touch it. If it doesn't disappear in a puff of smoke, then
				that block location isn't assigned to a flag number. You can use other blocks, they will simply do nothing if it doesn't find its location associated to a flag number.</p>
			</li>
			<li>
				<p>If the block do function but keeps respawning on level load, then that means there is something wrong with the following:</p>
				<ul>
					<li>
						<p>You forgot to use LM's conditional map16 for that block, or you set it to use the wrong flag number.</p>
					</li>
					<li>
						<p><kbd>MBCM16WriteGroup128To7FC060.asm</kbd> (uberasm tool library) isn't set up correctly, set to use the wrong level number or wrong group-128.</p>
					</li>
					<li>
						<p>You must've set the block to the wrong flag number that is assigned.</p>
					</li>
				</ul>
				<p>Otherwise if another block in the same level disappears, then you've set the block to the same flag number. This is correct for multi-block gates bigger than a 1x1 block
				so that the whole door remains gone when unlocked and level refreshes, however if 2+ separate things in the same level uses the same $7FC060 flag number, then both are affected,
				which any of them have been set to the wrong flag.</p>
			</li>
		</ul>
	</li>
	<li>
		You may be asking the question, why does the game lag if the player touches these MBCM16 blocks when they fail to trigger? This is because every frame the player touches the block, it has
		to search a long list of flag numbers (and fail to find the matching entry), which tanks the game's performance. The longer the list, the harder the game will slow down. However, if your
		entire hack does not contain any non-listed MBCM16 blocks (which your hack should have all of them be listed), you shouldn't worry, since the blocks execute for only 1 frame for a listed
		MBCM16 block the moment the block disappears.
	</li>
</ul>